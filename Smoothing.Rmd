---
title: "Smoothing"
output: pdf_document
date: "2025-12-06"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(forecast)
source("Data_Cleaning.R") 

Energy_monthly$price_transformed <- if (opt.lambda == 0) {
  log(Energy_monthly$price_monthly_avg)
} else {
  (Energy_monthly$price_monthly_avg^opt.lambda - 1) / opt.lambda
}
```

```{r}
price_transformed_ts <- ts(Energy_monthly$price_transformed,
                           start = c(start_y, start_m),
                           frequency = 12)
plot(price_transformed_ts)
acf(price_transformed_ts)
```

Residual diagnostic function
```{r setup, include=FALSE}
#Residual Diagnostic Functions

RegressionDiagnosicsPlots <- function(model) {
  # 1. Clean residuals once and store in a variable
  valid_residuals <- na.omit(as.numeric(model$residuals))
  
  # Check if enough data remains to plot
  if (length(valid_residuals) < 2) {
      stop("Residuals vector is too short after removing NAs. Cannot plot diagnostics.")
  }

  # setting up the plot layout
  layout_matrix <- matrix(c(1, 2, 3, 4, 5, 5), nrow = 3, byrow = TRUE)
  layout(layout_matrix)

  # filling up the layout with the actual plots
  hist(
    valid_residuals,
    breaks = 20, # <--- FIX IS HERE: Manually set the number of bins
    xlab = "Residuals",
    main = paste("Model =", deparse(substitute(model)))
  )
  # Apply valid_residuals to all subsequent calls:
  car::qqPlot(
    valid_residuals,
    pch = 16,
    col = adjustcolor("black", 0.7),
    xlab = "Theoretical Quantiles (Normal)",
    ylab = "Sample Quantiles (r.hat)",
    main = "Normal Q-Q Plot"
  )
  # For plot vs fitted, we must also clean the fitted values
  valid_fitted <- na.omit(as.numeric(model$fitted))
  
  # Ensure fitted and residuals are the same length for plotting
  # We assume the fitted values and residuals align after NA removal
  plot(
    valid_fitted[1:length(valid_residuals)],
    valid_residuals,
    pch = 16,
    col = adjustcolor("black", 0.5),
    xlab = "Fitted Values",
    ylab = "Residuals"
  )
  abline(h = 0, lty = 2, col = 'red')
  plot(
    valid_residuals, # Residuals vs index (Time)
    pch = 16,
    col = adjustcolor("black", 0.5),
    xlab = "Time",
    ylab = "Residuals"
  )
  abline(h = 0, lty = 2, col = 'red')
  acf(valid_residuals) # sample acf plot of residuals
  par(mfrow = c(1, 1)) # resetting the plot layout
}

#----------------------
RegressionDiagnosicsTests <- function(
  model,
  Fligner.test.segments = NULL 
) {
  residuals.model = residuals(model) # Extracting the residuals
  N = length(residuals.model) # Total number of residuals

  # --- Dynamic Segment Calculation ---
  if (is.null(Fligner.test.segments)) {
    num_segments <- 6 
    Fligner.test.segments <- factor(gl(
      num_segments, 
      ceiling(N / num_segments), 
      length = N
    ))
  } else {
    # If the user provides a vector, convert it to a factor for the test
    Fligner.test.segments <- factor(Fligner.test.segments)
  }

  # Testing normality and the homogeneity of the variance
  print(shapiro.test(residuals.model)) # Shapiro-Wilk test
  print(ks.test(residuals.model, "pnorm")) # Kolmogorov-Smirnov test

  # Fligner's test for homogeneity of variance across dynamic segments
  print(fligner.test(residuals.model, Fligner.test.segments))

  # Testing randomness of the residuals
  par(mfrow = c(1, 1))
  print(randtests::runs.test(residuals.model, plot = TRUE))
}
```

Using the Box-cox transformed data, try Holt-Winters Triple Smoothing and SARIMA models

**Holt-Winters Triple Smoothing**

CV function
```{r setup, include=FALSE}
# CV and AIC metric calculation function

calculate_metrics <- function(series, k, seasonal_type) {
  min_train <- 24 
  
  # --- 1. CROSS-VALIDATION FOR APSE ---
  
  remaining_len <- length(series) - min_train
  step_size <- floor(remaining_len / k)
  
  sse_sum <- 0
  total_forecast_points <- 0
  
  # Loop through k folds to calculate APSE 
  for (i in 0:(k-1)) {
    train_end <- min_train + i * step_size
    train_vec <- series[1:train_end]
    train_ts <- ts(train_vec, frequency = 12) 
    
    test_start <- train_end + 1
    test_end <- if (i == k - 1) length(series) else (train_end + step_size)
    
    test_vec <- series[test_start:test_end]
    h_horizon <- length(test_vec)
    
    tryCatch({
      model_cv <- HoltWinters(train_ts, seasonal = seasonal_type)
      pred <- predict(model_cv, n.ahead = h_horizon)
      
      sse_sum <- sse_sum + sum((test_vec - pred)^2)
      total_forecast_points <- total_forecast_points + h_horizon
      
    }, error = function(e) {
      message(paste("Convergence warning for", seasonal_type, "fold", i+1, ". APSE may be high."))
    })
  }
  
  # Calculate APSE
  apse_val <- if (total_forecast_points == 0) Inf else sse_sum / total_forecast_points
  
  
# --- 2. AIC AND AICc CALCULATION (In-Sample Fit) ---
  
  n <- length(series)
  full_ts <- ts(series, frequency = 12) 
  
  # Initialize AIC values to Inf in case of failure
  aic_val <- Inf
  aic_c_val <- Inf
  
  tryCatch({
    model_full <- HoltWinters(full_ts, seasonal = seasonal_type)
    
    # K: Number of estimated parameters (DOF for AIC/AICc) for s=12:
    # k = 3 smoothing parameters + 13 initial states = 16
    k_val <- 16 
    
    # SSE: Sum of Squared Errors from the full model fit
    sse <- model_full$SSE
    
    # 1. Calculate Log-Likelihood (LL) manually using SSE:
    # LL = -0.5 * n * log(2*pi) - 0.5 * n * log(SSE/n) - 0.5 * SSE / (SSE/n)
    # The last term simplifies to -n/2.
    ll_val <- -0.5 * n * log(2 * pi) - 0.5 * n * log(sse/n) - n / 2
    
    # 2. Calculate AIC:
    aic_val <- -2 * ll_val + 2 * k_val
    
    # 3. Calculate AICc:
    if (n - k_val - 1 > 0) {
      aic_c_correction <- 2 * k_val * (k_val + 1) / (n - k_val - 1)
      aic_c_val <- aic_val + aic_c_correction
    } 
    
  }, error = function(e) {
    message(paste("Error fitting final model for AIC/AICc:", e$message))
    # aic_val and aic_c_val remain Inf
  })
  
  
  # --- 3. RETURN RESULTS ---
  
  return(list(
    seasonal_type = seasonal_type,
    APSE = apse_val,
    AIC = aic_val,
    AICc = aic_c_val,
    k_folds = k
  ))
}
```

CV experiment
```{r}
#Run Cross-Validation Experiments

k_values <- c(3, 5, 10)
N = length(price_transformed_ts) # N is now correctly used inside the metrics function
set.seed(443)
models <- c("additive", "multiplicative")

# Define the new dataframe structure to hold all metrics
results_smoothing <- data.frame(
  k=integer(), 
  Model=character(), 
  APSE=double(), 
  AIC=double(), 
  AICc=double()
)

for (k in k_values) {
  for (type in models) {
    
    metrics <- calculate_metrics(price_transformed_ts, k, type)
    
    results_smoothing[nrow(results_smoothing) + 1, ] <- list(
      metrics$k_folds, 
      metrics$seasonal_type, 
      metrics$APSE, 
      metrics$AIC,
      metrics$AICc 
    )
    
    cat(sprintf("k=%d, Model=%s, APSE=%.4f, AIC=%.2f, AICc=%.2f\n", 
                metrics$k_folds, 
                metrics$seasonal_type, 
                metrics$APSE, 
                metrics$AIC, 
                metrics$AICc))
  }
}

print(results_smoothing)
```

Fit Model
```{r}
hw_mult_model <- HoltWinters(price_transformed_ts, seasonal = "multiplicative")
hw_mult_model$residuals = residuals(hw_mult_model)

hw_add_model <- HoltWinters(price_transformed_ts, seasonal = "additive")
hw_add_model$residuals = residuals(hw_add_model)
```

Residual Diagnostics
```{r}
print("-----------------HW Multiplicative-------------------")

RegressionDiagnosicsPlots(hw_mult_model)
RegressionDiagnosicsTests(hw_mult_model)

print("-----------------HW Additive-------------------")

RegressionDiagnosicsPlots(hw_add_model)
RegressionDiagnosicsTests(hw_add_model)
```

Prediction predict(transformed)
```{r}
pred_hw_add = predict(hw_add_model, n.ahead = 36, prediction.interval = T, level = 0.95 )
plot(hw_add_model, pred_hw_add, 
     main = "Additive Holt-Winters Smoothing (Transformed data)", 
     xlab = "Time",
     ylab = "Price (Transformed)")

# Add Vertical Lines for Horizons and Legend
abline(v = v_lines[1], col = "red", lty = 3)
abline(v = v_lines[2], col = "red", lty = 3)
abline(v = v_lines[3], col = "red", lty = 3)


```

Prediction predict(original)
```{r}
# Inverse Box-Cox function (for lambda != 0)
inverse_boxcox <- function(y, lambda) {
  return((y * lambda + 1)^(1/lambda))
}

# Define the original, untransformed historical data (for plotting context)
# Assuming Energy_monthly$price_monthly_avg, start_y, and start_m are available
price_original_ts <- ts(Energy_monthly$price_monthly_avg,
                       start = c(start_y, start_m),
                       frequency = 12)
original_ts <- price_original_ts

# --- 2. Generate Prediction Matrix using predict() ---

# The raw prediction matrix (in transformed units)
hw_pred_matrix <- predict(
  hw_add_model, 
  n.ahead = 36, 
  prediction.interval = TRUE, 
  level = 0.95
)


# --- 3. Apply Inverse Transformation (Manual Extraction) ---

# Column 1: Point Forecast (Mean)
mean_original <- inverse_boxcox(hw_pred_matrix[, 1], opt.lambda)

# Column 2: Lower 95% Bound
lower_95 <- inverse_boxcox(hw_pred_matrix[, 2], opt.lambda)

# Column 3: Upper 95% Bound
upper_95 <- inverse_boxcox(hw_pred_matrix[, 3], opt.lambda)


# --- 4. Manual Time Index Calculation ---

# Get historical time index
time_hist <- time(original_ts) 
end_time_hist <- time_hist[length(time_hist)]

# Create future time index for forecast lines
time_forecast_ts <- ts(
    data = mean_original,
    start = end_time_hist + (1/frequency(original_ts)), 
    frequency = 12
)
time_forecast_index <- time(time_forecast_ts)

# Get vertical line indices (1, 2, 3 years ahead)
v_lines <- c(end_time_hist + 1, end_time_hist + 2, end_time_hist + 3) 

# Set plot limits (must use na.rm=TRUE to handle any Inf/NA values)
y_min <- min(c(original_ts, lower_95, upper_95), na.rm = TRUE)
y_max <- max(c(original_ts, lower_95, upper_95), na.rm = TRUE)
x_lim <- range(time_hist, time_forecast_index)


# --- 5. Plotting in Original Units ---

# Plot Historical Data
plot(
  original_ts,
  main = "Additive Holt-Winters Smoothing (Original data)",
  xlab = "Time",
  ylab = "Price (Original)",
  ylim = c(y_min, y_max),
  xlim = x_lim,
  col = "black"
)

# --- Define Utility Function to Clean Data for plotting lines ---
clean_forecast_data <- function(y_data, time_index) {
  is_finite <- is.finite(y_data) 
  return(list(y_clean = y_data[is_finite], x_clean = time_index[is_finite]))
}

# Overlay the Prediction Interval (PI) Bounds (Must clean data first)
data_lower <- clean_forecast_data(lower_95, time_forecast_index)
lines(data_lower$x_clean, data_lower$y_clean, col = "gray", lty = 2)

data_upper <- clean_forecast_data(upper_95, time_forecast_index)
lines(data_upper$x_clean, data_upper$y_clean, col = "gray", lty = 2)

# Overlay the Point Forecast (Mean)
data_mean <- clean_forecast_data(mean_original, time_forecast_index)
lines(data_mean$x_clean, data_mean$y_clean, col = "blue", lwd = 2)

# Add Vertical Lines for Horizons and Legend
abline(v = v_lines[1], col = "red", lty = 3)
abline(v = v_lines[2], col = "red", lty = 3)
abline(v = v_lines[3], col = "red", lty = 3)

```





<!-- Prediction forecast(transformed) -->
<!-- ```{r} -->
<!-- h_ahead <- 36 # 3 years * 12 months = 36 steps -->

<!-- # Determine the time index of the last observed data point -->
<!-- end_time <- time(price_transformed_ts)[length(price_transformed_ts)] -->

<!-- v_lines <- c( -->
<!--   end_time + 1,  # 12 months ahead (1 year) -->
<!--   end_time + 2,  # 24 months ahead (2 years) -->
<!--   end_time + 3   # 36 months ahead (3 years) -->
<!-- ) -->

<!-- # Use the forecast function for automated PI calculation and plotting -->
<!-- hw_forecast <- forecast::forecast(hw_add_model, h = h_ahead, level = 95) -->


<!-- # --- 2. Plotting --- -->
<!-- plot( -->
<!--   hw_forecast,  -->
<!--   main = "Additive Holt-Winters Forecast and Prediction Intervals", -->
<!--   xlab = "Time (Years)", -->
<!--   ylab = "Price (Transformed Units)", -->
<!--   include = 80 # Adjust this value to show enough historical data -->
<!-- ) -->

<!-- # Add vertical lines marking the forecast horizons -->
<!-- abline(v = v_lines[1], col = "red", lty = 3, lwd = 1.5) -->
<!-- abline(v = v_lines[2], col = "darkorange", lty = 3, lwd = 1.5) -->
<!-- abline(v = v_lines[3], col = "blue", lty = 3, lwd = 1.5) -->

<!-- # Add legend for clarity -->
<!-- legend("topleft",  -->
<!--        legend = c("1 Year", "2 Years", "3 Years"), -->
<!--        col = c("red", "darkorange", "blue"), lty = 3, cex = 0.8) -->
<!-- ``` -->